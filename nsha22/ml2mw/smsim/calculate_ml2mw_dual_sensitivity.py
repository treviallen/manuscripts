from numpy import arange, around, array, random, delete, where, reshape, log10, sqrt, mean, floor
from os import system, path
from misc_tools import listdir_extension
from obspy import Trace

def read_smc_file(acc_file):
    # reads the "smc" file (synthetic accelerogram generated by smsim)
    # outputs the displacement as obspy trace object in SI format (meters)

    f = open(acc_file, 'r')
    lines = f.readlines()[40:]
    f.close()
    
    acc = []
    for ln in lines:
        for i in range(0, int(len(ln)/10)):
            acc.append(float(ln[10*i:10*(i + 1)]))
        
    acc = array(acc)
    l = len(acc) * 8
    #acc = reshape(acc, (1, l))[0]

    acc_tr = Trace()
    acc_tr.data = acc / 100.
    acc_tr.stats.sampling_rate = 100.
    acc_tr.stats.delta = 0.01

    disp_trace = acc_tr.copy().integrate().integrate()
    
    return disp_trace

def get_wa_amp(displacement_trace, sensitivity):
    from obspy.signal.invsim import corn_freq_2_paz
    
    corn_freq = 1.25
    
    # get W-A paz as per Uhrhammer & Collins (1990)    
    if sensitivity == 2800:
        damping = 0.8
    elif sensitivity == 2080:
        damping = 0.7
    
    paz = corn_freq_2_paz(corn_freq, damp=damping)
    
    # claculate the displacement amplitude from Wood-Anderson seismometer
    paz_wa = {'sensitivity': sensitivity, 'zeros': paz['zeros'], 'gain': 1,
              'poles': paz['poles']}
    disp_wa = displacement_trace.copy().simulate(paz_remove=None,
                                                 paz_simulate=paz_wa, water_level=10)

    ampl = max(abs(disp_wa.data))

    return ampl * 1000.


# run smsim
def run_smsim(m, d):
    # read base ctrl
    lines = open('allen07_a_ts_drvr_base.ctl').readlines()

    # now, write ctrl file
    lines[8] = '  simulations/m'+str('%0.2f' % m)+'r'+str('%0.1f' % d)+'_\n'
    lines[10] = '  '+str('%0.2f' % m)+' '+str('%0.1f' % d) + '\n'
    
    # write ctrl file
    f = open('allen07_a_ts_drvr.ctl', 'w')
    f.writelines(lines)
    f.close()
    
    # now call smsim
    system('./a_ts_drvr_mod')
    
################################################################################
# get event data

wa_sensitivity = [2800, 2080]
def get_event_data():
    from os import remove
    
    smcfiles = listdir_extension('simulations', 'smc')
    
    wa_amps_2800 = []
    wa_amps_2080 = []
    
    dists = []
    for smcfile in smcfiles:
        # get mag-dist from filename
        m = smcfile[1:5]
        r = smcfile.split('r')[-1].split('_')[0]
        dists.append(float(r))
        
        disp_trace = read_smc_file(path.join('simulations',smcfile)) # in m
        
        # get W-A amp for 2800
        wa_amps_2800.append(get_wa_amp(disp_trace, wa_sensitivity[0]))
        
        # get W-A amp for 2080
        wa_amps_2080.append(get_wa_amp(disp_trace, wa_sensitivity[1]))
        
        '''
        # add random Gaussian to WA amps                               
        rand_gaus = random.normal(loc=0., scale=0.25, size=1)
        wa_amp = 10**(log10(wa_amp) + rand_gaus[0])                     
        
        #data += ','.join((m, r, str(wa_amp))) + '\n'
        '''
        # now remove file
        remove(path.join('simulations',smcfile))
    return wa_amps_2800, wa_amps_2080, dists
    
################################################################################
def get_bvalue(mfd_mrng, mag_list, n_yrs):
    # get cumulative rates for mags >= m
    cum_num = []
    
    # add small number to deal with precission issues
    for m in mfd_mrng:
        midx = where(mag_list+1E-7 >= m)[0]    
        # set temp cum mags & times
        cum_num.append(len(midx))
        
    # get events per mag bin
    n_obs = []
    for r in range(0, len(cum_num)-1):
        n_obs.append(cum_num[r] - cum_num[r+1])
    n_obs.append(cum_num[-1])
    n_obs = array(n_obs)
    bin_rates = array(cum_num) / n_yrs
    
    # get bval
    mc = 1.8
    b_val, sigma_b = aki_maximum_likelihood(mfd_mrng, n_obs, mc)
    #a_val = fit_a_value(cum_num, bvals, mfd_mrng, mc, m_upper)
    
    return b_val, sigma_b, cum_num, n_obs, bin_rates

################################################################################

import pickle
from oq_tools import get_oq_incrementalMFD
from hazard_tools import bval2beta
from catalogue_tools import aki_maximum_likelihood, fit_a_value, weichert_algorithm
from calculate_magnitudes import calc_R35, calc_HB87, calc_MLM92, calc_BJ84
from misc_tools import dictlist2array, get_mpl2_colourlist, remove_last_cmap_colour
from gmt_tools import cpt2colormap 
from numpy import around, ones_like
from scipy.stats import norm, trim_mean
import matplotlib.pyplot as plt
import matplotlib as mpl
from os import getcwd
mpl.style.use('classic')

cmap = mpl.cm.get_cmap('Paired')

# set random seed
seed = 12345

#seed = 100
rand_seed = random.default_rng(seed)

# get num stations for given mag
def get_nstas(mag, rand_seed):
    import pickle
    numPDF = pickle.load(open("../numPDF.pkl", "rb" ))
    
    for npdf in numPDF: 
        if npdf['mmin'] >= mag and npdf['mmax'] < mag:
            #nstas = around(norm.rvs(npdf['mu'], npdf['std'], size=1))
            nstas = around(rand_seed.normal(npdf['mu'], npdf['std'], size=1))

    return nstas
    
# get get distances for given mag and nstas
def get_distances(mag, nstas, rand_seed):
    import pickle
    distPDF = pickle.load(open("../distPDF.pkl", "rb" ))
    
    for dpdf in distPDF: 
        if dpdf['mmin'] >= mag and dpdf['mmax'] < mag:
            try:
                #sample_dists = 10**(norm.rvs(dpdf['mu'], dpdf['std'], size=int(nstas)))
                sample_dists = 10**(rand_seed.normal(dpdf['mu'], dpdf['std'], size=int(nstas)))
            except: #try again!
                try:
                    #sample_dists = 10**(norm.rvs(dpdf['mu'], dpdf['std'], size=int(nstas)))
                    sample_dists = 10**(rand_seed.normal(dpdf['mu'], dpdf['std'], size=int(nstas)))
                except: #try again!
                    sample_dists = array([0])

    return sample_dists

################################################################################

fig = plt.figure(1, figsize=(7,8))
#cols = get_mpl2_colourlist()

if getcwd().startswith('/nas'):
    cptfile = '/nas/active/ops/community_safety/ehp/georisk_earthquake/hazard/DATA/cpt/Paired_10.cpt'
else:
    cptfile = '//Users//trev//Documents//DATA//GMT//cpt//Paired_10.cpt'
    
ncolours = 11
cmap, zvals = cpt2colormap(cptfile, ncolours)
cmap = remove_last_cmap_colour(cmap)
cs = (cmap(arange(ncolours-1)))

# get event set
bval_start = 1.2
beta = bval2beta(bval_start)

N0 = 1
mmin = 2.1
mmax = 7.3
binwid = 0.05

# get incremental curve
betacurve, mrng = get_oq_incrementalMFD(beta, N0, mmin, mmax, binwid)

# get M5 idx
idx5 = where(floor(mrng+0.01)==5.0)[0][0] # M 5 index

# sum rates M >= 5
m5_plus_rate = sum(betacurve[idx5:])

# get M 5 rate of 1 per 20 yrs
n_yrs = 20
target_m5_rate = 1 / n_yrs

# normalise betacurve by M 5 rate
target_curve = target_m5_rate * betacurve / m5_plus_rate

# sample beta curve
prob_curve = target_curve / sum(target_curve)

sigma_b = 1.
b_val = 0.
#binwid = 0.1
mfd_mrng = arange(2.1, 7.4, 0.1)
myrs = ones_like(mfd_mrng) * n_yrs
    
while sigma_b > 0.06: #0.042:
    # smaple events
    mag_sample = rand_seed.choice(mrng, size=500, p=prob_curve, replace=True) 
    
    b_val, sigma_b, cum_num, n_obs, bin_rates = get_bvalue(mfd_mrng, mag_sample, n_yrs)  # ignore b from this  
    b_val, sigma_b, a0, siga_m, fn0, stdfn0 = weichert_algorithm(myrs, \
                                           mfd_mrng+binwid/2, n_obs, mrate=0.0, \
                                           bval=1.2, itstab=1E-4, maxiter=1000)
    
    betacurve, mrng = get_oq_incrementalMFD(bval2beta(b_val), a0, mmin, mmax, binwid)
    
    print(b_val, sigma_b)
    
pidx = n_obs > 0
'''
plt.semilogy(mrng, betacurve, '-', c=cs[0], lw=2.)
plt.semilogy(mfd_mrng[pidx], bin_rates[pidx], 'o', c=cs[1], label='MW (b = '+str('%0.2f' % b_val)+')')
'''
#crash
                
# do smsim magic - only continue if within reasonable range!
events = []
#print('!!!!!!!!FIX ME!!!!!!!!!')
#if b_val > 1.17 and b_val < 1.23:

if b_val > 1.16 and b_val < 1.24:

    # loop thru mag sample
    for mag in mag_sample:
        # get sample number of stations
        nstas = 0
        while nstas < 3:
            nstas = get_nstas(mag, rand_seed)
        
        # get sample distances
        sample_dists = get_distances(mag, nstas, rand_seed)
        
        idx = sample_dists > 800.
        sample_dists = delete(sample_dists, idx)
        idx = sample_dists < 10.
        sample_dists = delete(sample_dists, idx)
        
        # run smsim
        if len(sample_dists) > 0:
            for dist in sample_dists:
                run_smsim(mag, dist)
                
            # get event data
            wa_amps_2800, wa_amps_2080, ev_dists = get_event_data()
            
            events.append({'mw':mag, 'wa_amps_2800':wa_amps_2800, 'wa_amps_2080':wa_amps_2080, 'dists':ev_dists})

################################################################################r
# calculate ML mags
################################################################################r

for j, event in enumerate(events):
    # do 2800 sensitivity
    bj84_2800 = []
    mlm92_2800 = []
    for i in range(0, len(event['wa_amps_2800'])):
        if event['dists'][i] < 10.:
            event['dists'][i] == 10
        
        repi = sqrt(event['dists'][i]**2 - 10**2)
        
        bj84_2800.append(calc_BJ84(1, log10(event['wa_amps_2800'][i]), event['dists'][i]) + 0.18) # added 0.18 as mean H-V correction - see hv_ratio.png in dropbox
        mlm92_2800.append(calc_MLM92(0, log10(event['wa_amps_2800'][i]), event['dists'][i]))
    
    events[j]['bj84_2800_stas'] = bj84_2800
    events[j]['bj84_2800_mean'] = trim_mean(bj84_2800, 0.1)
    events[j]['bj84_2800_res'] = bj84_2800 - events[j]['bj84_2800_mean']
    
    events[j]['mlm92_2800_stas'] = mlm92_2800
    events[j]['mlm92_2800_mean'] = trim_mean(mlm92_2800, 0.1)
    events[j]['mlm92_2800_res'] = mlm92_2800 - events[j]['mlm92_2800_mean']
    
    # do 2080 sensitivity
    bj84_2080 = []
    mlm92_2080 = []
    for i in range(0, len(event['wa_amps_2080'])):
        if event['dists'][i] < 10.:
            event['dists'][i] == 10
        
        repi = sqrt(event['dists'][i]**2 - 10**2)
        
        bj84_2080.append(calc_BJ84(1, log10(event['wa_amps_2080'][i]), event['dists'][i]) + 0.18) # added 0.18 as mean H-V correction - see hv_ratio.png in dropbox
        mlm92_2080.append(calc_MLM92(0, log10(event['wa_amps_2080'][i]), event['dists'][i]))
    
    events[j]['bj84_2080_stas'] = bj84_2080
    events[j]['bj84_2080_mean'] = trim_mean(bj84_2080, 0.1)
    events[j]['bj84_2080_res'] = bj84_2080 - events[j]['bj84_2080_mean']
    
    events[j]['mlm92_2080_stas'] = mlm92_2080
    events[j]['mlm92_2080_mean'] = trim_mean(mlm92_2080, 0.1)
    events[j]['mlm92_2080_res'] = mlm92_2080 - events[j]['mlm92_2080_mean']

# get arrays for regressing
bj84_2800_array = dictlist2array(events, 'bj84_2800_mean')
mlm92_2800_array = dictlist2array(events, 'mlm92_2800_mean') 

bj84_2080_array = dictlist2array(events, 'bj84_2080_mean')
mlm92_2080_array = dictlist2array(events, 'mlm92_2080_mean') 

mw_array = dictlist2array(events, 'mw') 

################################################################################r
# plot MW vs MW
################################################################################r

plt.plot(mlm92_2800_array, mw_array, 'o', ms=7, c='dodgerblue', label='W-A Sensitivity = 2800')
plt.plot(mlm92_2080_array, mw_array, 'o', ms=7, c='orange', label='W-A Sensitivity = 2080')
 
"""
# reset mag range for ML
ml_mfd_mrng = arange(1.8, 7.4, 0.1)
myrs = ones_like(ml_mfd_mrng) * n_yrs
mmin = 1.8

# get b-values for BJ84 and plot
b_val, sigma_b, cum_num, n_obs, bin_rates = get_bvalue(ml_mfd_mrng, bj84_array, n_yrs)  # ignore b from this  
b_val_bj84, sigma_b, a0, siga_m, fn0, stdfn0 = weichert_algorithm(myrs, \
                                               ml_mfd_mrng+binwid/2, n_obs, mrate=0.0, \
                                               bval=1.0, itstab=1E-4, maxiter=1000)
betacurve_bj84, mrng_bj84 = get_oq_incrementalMFD(bval2beta(b_val_bj84), a0, mmin, mmax, binwid)

# plot BJ84
pidx = n_obs > 0
plt.semilogy(mrng_bj84, betacurve_bj84, '-', c=cs[2], lw=2.)
plt.semilogy(ml_mfd_mrng[pidx], bin_rates[pidx], 'o', c=cs[3], label='ML BJ84 (b = '+str('%0.2f' % b_val_bj84)+')')

# get b-values for MLM92 and plot
b_val_mlm92, sigma_b, cum_num, n_obs, bin_rates = get_bvalue(ml_mfd_mrng, mlm92_array, n_yrs)
b_val_mlm92, sigma_b, a0, siga_m, fn0, stdfn0 = weichert_algorithm(myrs, \
                                                ml_mfd_mrng+binwid/2, n_obs, mrate=0.0, \
                                                bval=1.0, itstab=1E-4, maxiter=1000)
betacurve_mlm92, mrng_mlm92 = get_oq_incrementalMFD(bval2beta(b_val_mlm92), a0, mmin, mmax, binwid)

# plot
pidx = n_obs > 0
plt.semilogy(mrng_mlm92, betacurve_mlm92, '-', c=cs[6], lw=2.)
plt.semilogy(ml_mfd_mrng[pidx], bin_rates[pidx], 'o', c=cs[7], label='ML MLM92 (b = '+str('%0.2f' % b_val_mlm92)+')')

###############################################################################
# do post-hoc rate conversion

from mag_tools import nsha18_ml2mw

mw_mfd_mrng = nsha18_ml2mw(mrng_bj84)
plt.semilogy(mw_mfd_mrng, betacurve_bj84, 'k--', lw=2., label='Post hoc MW rates (BJ84)')
"""
################################################################################
# make pretty
plt.xlabel('ML', fontsize=16)
plt.ylabel('MW', fontsize=16)
plt.grid(which='both')
plt.legend(loc=2, numpoints=3)
plt.xlim([1.75, 7.0])
plt.ylim([1.75, 7.0])

plt.savefig('ml2mw_reg_var_wa_resp_'+str(seed)+'.png',format='png', dpi=300, bbox_inches='tight')
plt.show()

# save pickle
pickle.dump(events, open("simulated_ml_events.pkl", "wb"))